<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BBCode Image Downloader</title>
  <style>
    :root { --bg:#0b0f12; --card:#131a20; --muted:#8aa0b2; --text:#e7eef5; --accent:#69c; --danger:#f66; }
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(145deg,#0b0f12,#0e1216 55%,#0b0f12);color:var(--text)}
    .container{max-width:1100px;margin:32px auto;padding:0 16px}
    h1{margin:0 0 12px;font-size:28px}
    .card{background:var(--card);border:1px solid #1b232a;border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:grid;gap:12px}@media (min-width:900px){.row{grid-template-columns:2fr 1.2fr}}
    textarea{width:100%;min-height:220px;resize:vertical;background:#0f1419;color:var(--text);border:1px solid #1f2a33;border-radius:10px;padding:10px 12px;line-height:1.35}
    label{font-size:13px;color:var(--muted)}
    input[type="text"],input[type="number"]{width:100%;height:38px;background:#0f1419;color:var(--text);border:1px solid #1f2a33;border-radius:10px;padding:0 12px}
    .controls{display:grid;grid-template-columns:1.2fr 1fr 1fr 1fr;gap:10px;align-items:end;margin-top:10px}
    .controls .field{display:flex;flex-direction:column;gap:6px}
    .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
    button{appearance:none;border:1px solid #2a3742;background:#13202b;color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    button:hover{background:#0f1921;border-color:#3b4d5a}.btn-danger{background:#3a1010;border-color:#6e1f1f}
    .kpi{display:flex;gap:18px;flex-wrap:wrap;margin:10px 0 0;color:var(--muted);font-size:14px}.kpi b{color:var(--text)}
    .preview{margin-top:14px;display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(120px,1fr))}
    .thumb{position:relative;border-radius:12px;overflow:hidden;background:#0f1419;border:1px solid #1f2a33;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}.thumb .ix{position:absolute;top:6px;left:6px;background:rgba(0,0,0,.55);padding:2px 6px;border-radius:7px;font-size:12px}
    .log{background:#0f1419;border:1px solid #1f2a33;border-radius:10px;padding:10px 12px;height:160px;overflow:auto;white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#cfe2f2}
    .progress-wrap{margin-top:12px}progress{width:100%;height:16px}
    .note{color:var(--muted);font-size:13px;margin-top:8px}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0f1b23;border:1px solid #23323e;font-size:12px;color:var(--muted)}
    .tog{display:flex;align-items:center;gap:8px}
    .two{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .two .tog{border:1px solid #23323e;background:#0f1b23;padding:6px 10px;border-radius:10px}
  </style>
</head>
<body>
  <div class="container">
    <h1>BBCode Image Downloader</h1>
    <div class="card row">
      <div>
        <label for="inputText">Paste your HTML / BBCode</label>
        <textarea id="inputText" placeholder="[img]https://example.com/pic.jpg[/img] or [url=PHOTO_PAGE][img]THUMB.jpg[/img][/url]"></textarea>

        <div class="controls">
          <div class="field">
            <label for="folderName">Folder name (ZIP folder & filename prefix)</label>
            <input id="folderName" type="text" value="images_${new Date().toISOString().slice(0,10)}" />
          </div>
          <div class="field">
            <label for="concurrency">Concurrency</label>
            <input id="concurrency" type="number" min="1" max="12" value="4" />
          </div>
          <div class="field">
            <label for="proxyOrigin">Proxy (eg http://localhost:8787)</label>
            <input id="proxyOrigin" type="text" placeholder="http://localhost:8787" />
          </div>
          <div class="field tog">
            <input id="useProxy" type="checkbox" />
            <label for="useProxy">Use proxy</label>
          </div>
        </div>

        <div class="two">
          <label class="tog"><input id="useUrlTargets" type="checkbox" /> Use [url=...] targets</label>
          <label class="tog"><input id="resolveFull" type="checkbox" /> Resolve full-size from page (via proxy)</label>
          <label class="tog"><input id="preferOg" type="checkbox" checked /> Prefer og:image/twitter:image</label>
        </div>

        <div class="btns">
          <button id="extractBtn">Extract URLs</button>
          <button id="zipBtn">Download as ZIP</button>
          <button id="multiBtn">Direct multi‑download</button>
          <button id="clearBtn" class="btn-danger">Clear</button>
        </div>

        <div class="kpi" id="kpi">
          <div class="pill">Found: <b id="count">0</b></div>
          <div class="pill">Valid: <b id="valid">0</b></div>
          <div class="pill">Duplicates removed: <b id="dupes">0</b></div>
        </div>

        <div class="progress-wrap">
          <progress id="prog" value="0" max="100"></progress>
          <div class="note">If you see many <b>Failed to fetch</b>, enable <b>Use proxy</b> and run the included proxy. For full images from pages, check <b>Resolve full-size from page</b> (requires proxy).</div>
        </div>

        <div class="log" id="log" aria-live="polite"></div>
      </div>

      <div>
        <label>Preview</label>
        <div id="preview" class="preview"></div>
      </div>
    </div>

    <p class="note" style="margin-top:14px">
      ZIP mode gathers files via <code>fetch</code>; many hosts block cross-origin or need a Referer. The proxy adds those headers server-side. Direct multi-download uses normal browser downloads (fewer CORS issues, but no ZIP/folder control).
    </p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const $ = s => document.querySelector(s);
    const logEl = $("#log"), preview = $("#preview"), prog = $("#prog");
    const countEl = $("#count"), validEl = $("#valid"), dupesEl = $("#dupes");
    let urls = []; // final list of image URLs

    const sanitize = s => s.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 100);
    const basename = (u) => {
      try { const x = new URL(u); return (x.pathname.split("/").pop()||"file").split("?")[0]; }
      catch { return "file"; }
    };
    const log = (m)=>{ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight; };

    function extractFromBBCode(text) {
      const found = [];
      // capture [img]...[/img]
      const reImg = /\[img\]([^\[]+?)\[\/img\]/gi;
      let m; while ((m = reImg.exec(text)) !== null) found.push(m[1].trim());
      // capture <img src="...">
      const reHtml = /<img[^>]+src=['"]([^'">]+)['"]/gi;
      while ((m = reHtml.exec(text)) !== null) found.push(m[1].trim());
      // generic image URLs
      const reUrl = /(https?:\/\/[\w\-._~:/?#\[\]@!$&'()*+,;=%]+\.(?:png|jpe?g|gif|webp|bmp|svg)(?:\?[^\s'"]*)?)/gi;
      while ((m = reUrl.exec(text)) !== null) found.push(m[1].trim());
      return found;
    }

    function extractPageLinks(text) {
      const targets = [];
      const reUrlTag = /\[url=([^\]]+)\][\s\S]*?\[\/url\]/gi;
      let m; while ((m = reUrlTag.exec(text)) !== null) { targets.push(m[1].trim()); }
      return targets;
    }

    function uniqHttp(list) {
      const uniq = [], seen = new Set();
      for (const u of list) {
        if (!/^https?:\/\//i.test(u)) continue;
        if (seen.has(u)) continue;
        seen.add(u); uniq.push(u);
      }
      return uniq;
    }

    function renderPreview(list) {
      preview.innerHTML = "";
      list.forEach((u,i)=>{
        const div = document.createElement("div"); div.className="thumb";
        const img = document.createElement("img"); img.loading="lazy"; img.referrerPolicy="no-referrer"; img.src=u;
        const ix = document.createElement("div"); ix.className="ix"; ix.textContent=String(i+1);
        div.appendChild(img); div.appendChild(ix); preview.appendChild(div);
      });
    }

    async function resolveFullFromPages(pages) {
      const useProxy = $("#useProxy").checked;
      const origin = ($("#proxyOrigin").value||"").trim();
      if (!useProxy || !origin) { alert("Resolving from pages requires proxy. Enable Use proxy and set origin."); return []; }
      log("Resolving full-size image URLs from photo pages via proxy...");
      const out = [];
      let done=0; prog.max = pages.length; prog.value=0;
      for (const p of pages) {
        try {
          const res = await fetch(origin.replace(/\/$/,'') + "/proxy?url=" + encodeURIComponent(p), { mode:"cors" });
          if (!res.ok) throw new Error("HTTP "+res.status);
          const html = await res.text();
          // Try og:image or twitter:image first
          let m;
          m = html.match(/<meta\s+property=["']og:image["']\s+content=["']([^"']+)["']/i);
          if (!m) m = html.match(/<meta\s+name=["']twitter:image["']\s+content=["']([^"']+)["']/i);
          // Fallback: first plausible <img> (very light heuristic)
          if (!m) {
            const imgs = Array.from(html.matchAll(/<img[^>]+src=["']([^"']+)["'][^>]*>/gi)).map(mm=>mm[1]);
            const pref = imgs.find(u=>/\.(?:jpg|jpeg|png|webp)(?:\?|$)/i.test(u) && /full|large|big|photo/i.test(u));
            out.push(pref || imgs[0] || p);
          } else {
            out.push(m[1]);
          }
        } catch(e) {
          log("Resolve FAIL: "+p+" — "+e.message);
          out.push(p);
        } finally {
          done++; prog.value=done;
        }
      }
      return uniqHttp(out);
    }

    $("#extractBtn").addEventListener("click", async () => {
      const text = $("#inputText").value || "";
      const useTargets = $("#useUrlTargets").checked;
      const wantResolve = $("#resolveFull").checked;

      const imgCandidates = extractFromBBCode(text);
      let final = uniqHttp(imgCandidates);

      if (useTargets) {
        const pages = uniqHttp(extractPageLinks(text));
        if (pages.length) {
          if (wantResolve) {
            const resolved = await resolveFullFromPages(pages);
            final = uniqHttp(final.concat(resolved));
          } else {
            final = uniqHttp(final.concat(pages));
          }
        }
      }

      urls = final;
      countEl.textContent = String(imgCandidates.length);
      validEl.textContent = String(final.length);
      dupesEl.textContent = String(imgCandidates.length - final.length);
      renderPreview(urls);
      log(`Found ${final.length} valid URLs (images + ${useTargets ? "targets" : "no targets"}).`);
    });

    $("#clearBtn").addEventListener("click", () => {
      $("#inputText").value = ""; urls = [];
      countEl.textContent = validEl.textContent = dupesEl.textContent = "0";
      preview.innerHTML = ""; prog.value = 0; logEl.textContent="";
    });

    async function zipDownload() {
      if (!urls.length) { alert("No URLs extracted yet."); return; }
      const useProxy = $("#useProxy").checked;
      const origin = ($("#proxyOrigin").value||"").trim();
      if (useProxy && !origin) { alert("Set Proxy origin or uncheck Use proxy."); return; }

      const folder = ($("#folderName").value||"images").trim();
      const concurrency = Math.max(1, Math.min(12, parseInt($("#concurrency").value||"4", 10)));
      log(`Starting ZIP for ${urls.length} (concurrency=${concurrency}, proxy=${useProxy?origin:"no"})`);

      const zip = new JSZip();
      const folderZip = zip.folder(folder)||zip;
      let done=0, failed=0; prog.max=urls.length; prog.value=0;

      const tasks = urls.map((u, idx) => async () => {
        const name = sanitize(String(idx+1).padStart(3,"0")+"_"+basename(u));
        const target = useProxy ? origin.replace(/\/$/,'') + "/proxy?url=" + encodeURIComponent(u) : u;
        try {
          const res = await fetch(target, { mode:"cors", referrerPolicy:"no-referrer" });
          if (!res.ok) throw new Error("HTTP "+res.status);
          const blob = await res.blob();
          folderZip.file(name, blob);
          done++; prog.value = done+failed;
          if ((done+failed)%10===0 || done+failed===urls.length) log(`Fetched ${done}/${urls.length}...`);
        } catch(e) {
          failed++; prog.value = done+failed;
          log("FAIL "+name+": "+e.message);
        }
      });

      const pool=[]; let i=0;
      for (let k=0;k<concurrency;k++) {
        pool.push((async function worker(){ while (i<tasks.length) { const t=tasks[i++]; await t(); } })());
      }
      await Promise.all(pool);

      log("Packaging ZIP...");
      const blob = await zip.generateAsync({type:"blob", compression:"DEFLATE", compressionOptions:{level:6}});
      const ts = new Date().toISOString().replace(/[:.]/g,"-");
      const name = sanitize(folder)+"_"+ts+".zip";
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 15000);
      log(`ZIP ready: ${name}. Success: ${done}, Failed: ${failed}.`);
    }

    async function multiDownload() {
      if (!urls.length) { alert("No URLs extracted yet."); return; }
      const prefix = ($("#folderName").value||"images").trim();
      log("Starting direct multi‑download...");
      let idx = 0; prog.max = urls.length; prog.value = 0;
      const next = () => {
        if (idx>=urls.length) { log("All download requests queued."); return; }
        const u = urls[idx];
        const name = sanitize(String(idx+1).padStart(3,"0")+"_"+prefix+"_"+basename(u));
        const a = document.createElement("a"); a.href=u; a.rel="noreferrer"; a.download=name;
        document.body.appendChild(a); a.click(); a.remove();
        idx++; prog.value = idx;
        setTimeout(next, 300);
      };
      next();
    }

    $("#zipBtn").addEventListener("click", zipDownload);
    $("#multiBtn").addEventListener("click", multiDownload);
  </script>
</body>
</html>
