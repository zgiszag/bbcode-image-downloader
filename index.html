<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BBCode Image Downloader</title>
  <style>
    :root { --bg:#0b0f12; --card:#131a20; --muted:#8aa0b2; --text:#e7eef5; --accent:#69c; --danger:#f66; }
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(145deg,#0b0f12,#0e1216 55%,#0b0f12);color:var(--text)}
    .container{max-width:1100px;margin:32px auto;padding:0 16px}
    h1{margin:0 0 12px;font-size:28px}
    .card{background:var(--card);border:1px solid #1b232a;border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:grid;gap:12px}@media (min-width:900px){.row{grid-template-columns:2fr 1.2fr}}
    textarea{width:100%;min-height:220px;resize:vertical;background:#0f1419;color:var(--text);border:1px solid #1f2a33;border-radius:10px;padding:10px 12px;line-height:1.35}
    label{font-size:13px;color:var(--muted)}
    input[type="text"],input[type="number"]{width:100%;height:38px;background:#0f1419;color:var(--text);border:1px solid #1f2a33;border-radius:10px;padding:0 12px}
    .controls{display:grid;grid-template-columns:1.3fr 1fr 1fr 1fr;gap:10px;align-items:end;margin-top:10px}
    .controls .field{display:flex;flex-direction:column;gap:6px}
    .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
    button{appearance:none;border:1px solid #2a3742;background:#13202b;color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    button:hover{background:#0f1921;border-color:#3b4d5a}.btn-danger{background:#3a1010;border-color:#6e1f1f}
    .kpi{display:flex;gap:18px;flex-wrap:wrap;margin:10px 0 0;color:var(--muted);font-size:14px}.kpi b{color:var(--text)}
    .preview{margin-top:14px;display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(120px,1fr))}
    .thumb{position:relative;border-radius:12px;overflow:hidden;background:#0f1419;border:1px solid #1f2a33;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}.thumb .ix{position:absolute;top:6px;left:6px;background:rgba(0,0,0,.55);padding:2px 6px;border-radius:7px;font-size:12px}
    .log{background:#0f1419;border:1px solid #1f2a33;border-radius:10px;padding:10px 12px;height:180px;overflow:auto;white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#cfe2f2}
    .progress-wrap{margin-top:12px}progress{width:100%;height:16px}
    .note{color:var(--muted);font-size:13px;margin-top:8px}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0f1b23;border:1px solid #23323e;font-size:12px;color:var(--muted)}
    .tog{display:flex;align-items:center;gap:8px}
    .chips{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .chips .tog{border:1px solid #23323e;background:#0f1b23;padding:6px 10px;border-radius:10px}
  </style>
</head>
<body>
  <div class="container">
    <h1>BBCode Image Downloader</h1>
    <div class="card row">
      <div>
        <label for="inputText">Paste your HTML / BBCode</label>
        <textarea id="inputText" placeholder="[url=https://www.imagefap.com/photo/ID][img]THUMB.jpg[/img][/url]"></textarea>

        <div class="controls">
          <div class="field">
            <label for="folderName">Folder name (ZIP folder & filename prefix)</label>
            <input id="folderName" type="text" value="images_${new Date().toISOString().slice(0,10)}" />
          </div>
          <div class="field">
            <label for="concurrency">Concurrency</label>
            <input id="concurrency" type="number" min="1" max="12" value="4" />
          </div>
          <div class="field">
            <label for="proxyOrigin">Proxy (eg http://localhost:8787)</label>
            <input id="proxyOrigin" type="text" placeholder="http://localhost:8787" />
          </div>
          <div class="field tog">
            <input id="useProxy" type="checkbox" />
            <label for="useProxy">Use proxy</label>
          </div>
        </div>

        <div class="chips">
          <label class="tog"><input id="useUrlTargets" type="checkbox" checked /> Use [url=...] targets</label>
          <label class="tog"><input id="resolveFull" type="checkbox" checked /> Resolve full-size from page (via proxy)</label>
          <label class="tog"><input id="preferOg" type="checkbox" /> Prefer og:image/twitter:image (disable for ImageFap)</label>
          <label class="tog"><input id="fixExtensions" type="checkbox" checked /> Fix file extension by Content-Type</label>
        </div>

        <div class="btns">
          <button id="extractBtn">Extract URLs</button>
          <button id="zipBtn">Download as ZIP</button>
          <button id="clearBtn" class="btn-danger">Clear</button>
        </div>

        <div class="kpi" id="kpi">
          <div class="pill">Found: <b id="count">0</b></div>
          <div class="pill">Valid: <b id="valid">0</b></div>
          <div class="pill">Duplicates removed: <b id="dupes">0</b></div>
        </div>

        <div class="progress-wrap">
          <progress id="prog" value="0" max="100"></progress>
          <div class="note">Site-specific resolver for <b>imagefap.com</b> that reads the page and fetches the <code>#photo</code> / full-size image with the page as Referer. Use the proxy.</div>
        </div>

        <div class="log" id="log" aria-live="polite"></div>
      </div>

      <div>
        <label>Preview</label>
        <div id="preview" class="preview"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const $ = s => document.querySelector(s);
    const logEl = $("#log"), preview = $("#preview"), prog = $("#prog");
    const countEl = $("#count"), validEl = $("#valid"), dupesEl = $("#dupes");

    // items: { url: string, ref?: string }
    let items = [];

    const sanitize = s => s.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 100);
    const extFromCT = (ct) => {
      ct = (ct||"").toLowerCase();
      if (ct.includes("jpeg")) return ".jpg";
      if (ct.includes("png")) return ".png";
      if (ct.includes("gif")) return ".gif";
      if (ct.includes("webp")) return ".webp";
      if (ct.includes("bmp")) return ".bmp";
      if (ct.includes("svg")) return ".svg";
      return "";
    };
    const basename = (u) => { try { const x = new URL(u); return (x.pathname.split("/").pop()||"file").split("?")[0]; } catch { return "file"; } };
    const makeAbs = (maybeUrl, base) => { try { return new URL(maybeUrl, base).toString(); } catch { return maybeUrl; } };
    const log = (m)=>{ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight; };

    function extractFromBBCode(text) {
      const found = [];
      const reImg = /\[img\]([^\[]+?)\[\/img\]/gi;
      let m; while ((m = reImg.exec(text)) !== null) found.push({url:m[1].trim()});
      const reHtml = /<img[^>]+src=['"]([^'">]+)['"]/gi;
      while ((m = reHtml.exec(text)) !== null) found.push({url:m[1].trim()});
      const reUrl = /(https?:\/\/[\w\-._~:/?#\[\]@!$&'()*+,;=%]+\.(?:png|jpe?g|gif|webp|bmp|svg)(?:\?[^\s'"]*)?)/gi;
      while ((m = reUrl.exec(text)) !== null) found.push({url:m[1].trim()});
      return found;
    }
    function extractPageLinks(text) {
      const targets = [];
      const reUrlTag = /\[url=([^\]]+)\][\s\S]*?\[\/url\]/gi;
      let m; while ((m = reUrlTag.exec(text)) !== null) targets.push(m[1].trim());
      return targets;
    }
    function uniqByUrl(list) {
      const uniq = [], seen = new Set();
      for (const it of list) {
        const u = it.url;
        if (!/^https?:\/\//i.test(u)) continue;
        if (seen.has(u)) continue;
        seen.add(u); uniq.push(it);
      }
      return uniq;
    }

    function renderPreview(list) {
      preview.innerHTML = "";
      list.forEach((it,i)=>{
        const div = document.createElement("div"); div.className="thumb";
        const img = document.createElement("img"); img.loading="lazy"; img.referrerPolicy="no-referrer"; img.src=it.url;
        const ix = document.createElement("div"); ix.className="ix"; ix.textContent=String(i+1);
        div.appendChild(img); div.appendChild(ix); preview.appendChild(div);
      });
    }

    async function fetchTextViaProxy(url, ref) {
      const useProxy = $("#useProxy").checked;
      const origin = ($("#proxyOrigin").value||"").trim();
      if (!useProxy || !origin) throw new Error("Proxy required for cross-origin HTML");
      const prox = origin.replace(/\/$/,'') + "/proxy?url=" + encodeURIComponent(url) + (ref ? "&ref=" + encodeURIComponent(ref) : "");
      const res = await fetch(prox, { mode:"cors" });
      if (!res.ok) throw new Error("HTTP "+res.status);
      return res.text();
    }

    function extractLargestFromSrcset(srcset, base) {
      if (!srcset) return null;
      try {
        const parts = srcset.split(",").map(s=>s.trim()).filter(Boolean);
        if (!parts.length) return null;
        const last = parts[parts.length-1].split(" ")[0];
        return makeAbs(last, base);
      } catch { return null; }
    }

    function imagefapPickFull(doc, pageUrl) {
      // 1) Specific selectors seen on ImageFap variants
      const cand = doc.querySelector("img#photo, img#mainPhoto, img.photo, img#image, img#thepic, img#pic");
      if (cand) {
        const ss = cand.getAttribute("srcset");
        if (ss) {
          const best = extractLargestFromSrcset(ss, pageUrl);
          if (best) return best;
        }
        const src = cand.getAttribute("src") || cand.getAttribute("data-src") || cand.getAttribute("data-big-src");
        if (src) return makeAbs(src, pageUrl);
      }
      // 2) Look for download links
      const a = doc.querySelector('a[href*="download"], a#download, a.download, a.downloadLink');
      if (a && a.getAttribute("href")) return makeAbs(a.getAttribute("href"), pageUrl);
      // 3) Fallback: biggest plausible <img>
      const imgs = Array.from(doc.querySelectorAll("img"));
      // prefer ones containing "full", "big", "photo"
      const pref = imgs.find(im => /\.(?:jpg|jpeg|png|webp)(?:\?|$)/i.test(im.src) && /full|large|big|photo|image/i.test(im.src));
      if (pref) return makeAbs(pref.getAttribute("src"), pageUrl);
      if (imgs[0]) return makeAbs(imgs[0].getAttribute("src"), pageUrl);
      return null;
    }

    async function resolveFromPage(pageUrl) {
      // Avoid og:image for ImageFap; it's often a thumb
      const html = await fetchTextViaProxy(pageUrl, null);
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");

      const host = (new URL(pageUrl)).hostname;
      let candidate = null;

      if (/imagefap\.com$/i.test(host)) {
        candidate = imagefapPickFull(doc, pageUrl);
      }
      // Generic fallback if still nothing: og:image or twitter:image
      if (!candidate && $("#preferOg").checked) {
        const og = doc.querySelector('meta[property="og:image"][content], meta[name="twitter:image"][content]');
        if (og) candidate = makeAbs(og.getAttribute("content"), pageUrl);
      }
      // Final generic fallback: first image
      if (!candidate) {
        const any = doc.querySelector("img");
        if (any) candidate = makeAbs(any.getAttribute("src"), pageUrl);
      }
      return candidate || pageUrl;
    }

    $("#extractBtn").addEventListener("click", async () => {
      const text = $("#inputText").value || "";
      const wantTargets = $("#useUrlTargets").checked;
      const wantResolve = $("#resolveFull").checked;

      const imgItems = extractFromBBCode(text);
      let out = [...imgItems];
      const pages = wantTargets ? extractPageLinks(text) : [];

      if (pages.length && wantResolve) {
        log("Resolving full-size images from pages (with per-page Referer)...");
        prog.max = pages.length; prog.value = 0; let done=0;
        for (const p of pages) {
          try {
            const real = await resolveFromPage(p);
            out.push({url: real, ref: p}); // keep referrer for proxy
          } catch (e) {
            log("Resolve FAIL: "+p+" — "+e.message);
            out.push({url:p});
          } finally {
            done++; prog.value = done;
          }
        }
      } else if (pages.length) {
        out = out.concat(pages.map(p => ({url:p})));
      }

      items = uniqByUrl(out);
      countEl.textContent = String(imgItems.length);
      validEl.textContent = String(items.length);
      dupesEl.textContent = String(imgItems.length - items.length);
      renderPreview(items);
      log(`Prepared ${items.length} URLs.`);
    });

    $("#clearBtn").addEventListener("click", () => {
      $("#inputText").value = ""; items = [];
      countEl.textContent = validEl.textContent = dupesEl.textContent = "0";
      preview.innerHTML = ""; prog.value = 0; logEl.textContent="";
    });

    async function fetchBlobViaProxy(u, ref) {
      const useProxy = $("#useProxy").checked;
      const origin = ($("#proxyOrigin").value||"").trim();
      if (!useProxy || !origin) {
        // Try direct, may fail due to CORS
        const res = await fetch(u, { mode:"cors", referrerPolicy:"no-referrer" });
        if (!res.ok) throw new Error("HTTP "+res.status);
        return res;
      }
      const prox = origin.replace(/\/$/,'') + "/proxy?url=" + encodeURIComponent(u) + (ref ? "&ref=" + encodeURIComponent(ref) : "");
      const res = await fetch(prox, { mode:"cors" });
      if (!res.ok) throw new Error("HTTP "+res.status);
      return res;
    }

    async function zipDownload() {
      if (!items.length) { alert("No URLs extracted yet."); return; }
      const useProxy = $("#useProxy").checked;
      const origin = ($("#proxyOrigin").value||"").trim();
      if (useProxy && !origin) { alert("Set Proxy origin or uncheck Use proxy."); return; }

      const folder = ($("#folderName").value||"images").trim();
      const concurrency = Math.max(1, Math.min(12, parseInt($("#concurrency").value||"4", 10)));
      log(`Starting ZIP for ${items.length} (concurrency=${concurrency}, proxy=${useProxy?origin:"no"})`);

      const zip = new JSZip();
      const folderZip = zip.folder(folder)||zip;
      let done=0, failed=0; prog.max=items.length; prog.value=0;
      const manifest = [];

      const tasks = items.map((it, idx) => async () => {
        try {
          const res = await fetchBlobViaProxy(it.url, it.ref);
          const ct = res.headers.get("content-type")||"";
          if (!ct.startsWith("image/")) throw new Error("Non-image Content-Type: "+ct);
          const blob = await res.blob();
          if (blob.size === 0) throw new Error("Empty file");

          let name = sanitize(String(idx+1).padStart(3,"0")+"_"+basename(it.url));
          if ($("#fixExtensions").checked) {
            const ext = extFromCT(ct) || "";
            const baseNoExt = name.replace(/\.[^.]+$/, "");
            name = baseNoExt + (ext || "");
          }
          folderZip.file(name, blob);
          done++; manifest.push(`OK   ${name} <- ${it.url}${it.ref? " (ref "+it.ref+")":""}`);
        } catch (e) {
          failed++; manifest.push(`FAIL ${it.url}${it.ref? " (ref "+it.ref+")":""} :: ${e.message}`);
          log(`FAIL ${idx+1}: ${e.message}`);
        }
        prog.value = done + failed;
        if ((done+failed)%10===0 || done+failed===items.length) log(`Progress ${done}/${items.length}...`);
      });

      const pool=[]; let i=0;
      for (let k=0;k<concurrency;k++) {
        pool.push((async function worker(){ while (i<tasks.length) { const t=tasks[i++]; await t(); } })());
      }
      await Promise.all(pool);

      folderZip.file("_manifest.txt", manifest.join("\n"));
      log("Packaging ZIP...");
      const blob = await zip.generateAsync({type:"blob", compression:"DEFLATE", compressionOptions:{level:6}});
      const ts = new Date().toISOString().replace(/[:.]/g,"-");
      const name = sanitize(folder)+"_"+ts+".zip";
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 15000);
      log(`ZIP ready: ${name}. Success: ${done}, Failed: ${failed}. Check _manifest.txt for details.`);
    }

    $("#zipBtn").addEventListener("click", zipDownload);
  </script>
</body>
</html>
